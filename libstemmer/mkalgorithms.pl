#!/usr/bin/env perl
use strict;
use 5.006;
use warnings;

my $progname = $0;

if (scalar @ARGV != 2) {
  print "Usage: $progname <outfile> <modules description file>\n";
  exit 1;
}

my $outname = shift(@ARGV);
my $descfile = shift(@ARGV);

my %aliases = ();
my %algorithms = ();
my %algorithm_encs = ();

my %encs = ();

sub addalgenc($$) {
  my $alg = shift();
  my $enc = shift();

  if (defined $algorithm_encs{$alg}) {
      my $hashref = $algorithm_encs{$alg};
      $$hashref{$enc}=1;
  } else {
      my %newhash = ($enc => 1);
      $algorithm_encs{$alg}=\%newhash;
  }

  $encs{$enc} = 1;
}

sub readinput()
{
    open DESCFILE, $descfile;
    my $line;
    while($line = <DESCFILE>)
    {
        next if $line =~ m/^\s*#/;
        next if $line =~ m/^\s*$/;
        my ($alg,$encstr,$aliases) = split(/\s+/, $line);
        my $enc;
        my $alias;

        $algorithms{$alg} = 1;
        foreach $alias (split(/,/, $aliases)) {
            foreach $enc (split(/,/, $encstr)) {
                # print "$alias, $enc\n";
                $aliases{$alias} = $alg;
                addalgenc($alg, $enc);
            }
        }
    }
}

sub printoutput()
{
    open (OUT, ">$outname") or die "Can't open output file `$outname': $!\n";

    print OUT <<EOS;
# $outname: Lists of stemming modules.
#
# This file is generated by mkalgorithmsmk.pl from a list of module names.
# Do not edit manually.
EOS

    my $need_sep = 0;
    my $lang;
    my $enc;
    my @algorithms = sort keys(%algorithms);
    print OUT "\nlibstemmer_algorithms =";
    foreach $lang (@algorithms) {
	print OUT "\\\n    ", $lang;
    }
    print OUT "\n";

    for my $enc (qw(ISO_8859_1 ISO_8859_2 KOI8_R)) {
	print OUT "\n${enc}_algorithms =";
	foreach $lang (@algorithms) {
	    print OUT "\\\n    ", $lang if exists $algorithm_encs{$lang}->{$enc};
	}
	print OUT "\n";
    }
###     print OUT "\nlibstemmer_algorithms =";
###     foreach $lang (@algorithms) {
### 	print OUT "\\\n", $lang;
###     }
###     print OUT "\n";
### 
###     foreach $lang (@algorithms) {
###         my $hashref = $algorithm_encs{$lang};
###         foreach $enc (sort keys (%$hashref)) {
###             print OUT "#include \"../$c_src_dir/stem_${enc}_$lang.h\"\n";
###         }
###     }
### 
###     print OUT <<EOS;
### 
### typedef enum {
###   ENC_UNKNOWN=0,
### EOS
###     my $neednl = 0;
###     for $enc (sort keys %encs) {
###         print OUT ",\n" if $neednl;
###         print OUT "  ENC_${enc}";
###         $neednl = 1;
###     }
###     print OUT <<EOS;
### 
### } stemmer_encoding_t;
### 
### struct stemmer_encoding {
###   const char * name;
###   stemmer_encoding_t enc;
### };
### static struct stemmer_encoding encodings[] = {
### EOS
###     for $enc (sort keys %encs) {
###         print OUT "  {\"${enc}\", ENC_${enc}},\n";
###     }
###     print OUT <<EOS;
###   {0,ENC_UNKNOWN}
### };
### 
### struct stemmer_modules {
###   const char * name;
###   stemmer_encoding_t enc; 
###   struct SN_env * (*create)(void);
###   void (*close)(struct SN_env *);
###   int (*stem)(struct SN_env *);
### };
### static struct stemmer_modules modules[] = {
### EOS
### 
###     for $lang (sort keys %aliases) {
###         my $l = $aliases{$lang};
###         my $hashref = $algorithm_encs{$l};
###         my $enc;
###         foreach $enc (sort keys (%$hashref)) {
###             my $p = "${l}_${enc}";
###             print OUT "  {\"$lang\", ENC_$enc, ${p}_create_env, ${p}_close_env, ${p}_stem},\n";
###         }
###     }
### 
###     print OUT <<EOS;
###   {0,ENC_UNKNOWN,0,0,0}
### };
### EOS
### 
###     print OUT <<EOS;
### static const char * algorithm_names[] = {
### EOS
### 
###     for $lang (@algorithms) {
###         my $l = $aliases{$lang};
###         print OUT "  \"$lang\", \n";
###     }
### 
###     print OUT <<EOS;
###   0
### };
### EOS
###     close OUT or die "Can't close ${outname}: $!\n";
}

readinput();
printoutput();
